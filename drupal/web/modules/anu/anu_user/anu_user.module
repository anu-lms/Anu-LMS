<?php

/**
 * @file
 * Helper module for User functionality.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Site\Settings;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Url;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\consumers\Entity\Consumer;
use Drupal\user\UserInterface;

/**
 * Implements hook_token_info().
 */
function anu_user_token_info() {
  $info['tokens']['user']['frontend-one-time-login-url'] = [
    'name' => t('One-time login URL to the Frontend'),
    'description' => t('The URL of the one-time login page for the user account.'),
    'restricted' => TRUE,
  ];
  $info['tokens']['site']['frontend-url'] = [
    'name' => t('URL to the Frontend'),
    'description' => t('The URL of the Frontend application.'),
    'restricted' => TRUE,
  ];

  return $info;
}

/**
 * Implements hook_tokens()
 */
function anu_user_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];

  if ($type == 'user' && !empty($data['user'])) {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'frontend-one-time-login-url':

          $replacements[$original] = anu_user_pass_reset_url($data['user'], $options);
          break;
      }
    }
  }
  elseif ($type == 'site') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'frontend-url':

          $replacements[$original] = Settings::get('frontend_domain');
          break;
      }
    }
  }
  return $replacements;
}

/**
 * Generates a unique URL for a user to log in and reset their password.
 *
 * @param \Drupal\user\UserInterface $account
 *   An object containing the user account.
 * @param array $options
 *   (optional) A keyed array of settings. Supported options are:
 *   - langcode: A language code to be used when generating locale-sensitive
 *    URLs. If langcode is NULL the users preferred language is used.
 *
 * @return string
 *   A unique URL that provides a one-time log in for the user, from which
 *   they can change their password.
 */
function anu_user_pass_reset_url(UserInterface $account, array $options = []) {
  $timestamp = \Drupal::time()->getRequestTime();
  $uid = $account->id();
  $hash = user_pass_rehash($account, $timestamp);
  $frontend_domain = Settings::get('frontend_domain');
  $langcode = isset($options['langcode']) ? $options['langcode'] : $account->getPreferredLangcode();
  $url = Url::fromUri($frontend_domain . "user/reset/$uid/$timestamp/$hash",
    [
      'absolute' => TRUE,
      'language' => \Drupal::languageManager()->getLanguage($langcode),
    ]
  );
  return $url->toString();
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function anu_user_form_user_login_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['#validate'][] = '_anu_backend_login_validate';
}

/**
 * Validates user account during backend authentication.
 *
 * Only managers and administrators may access backend.
 */
function _anu_backend_login_validate(&$form, FormStateInterface $form_state) {
  if ($form_state->hasValue('name')) {
    $name = $form_state->getValue('name');

    $user = user_load_by_name($name);

    if (!$user) {
      $user = user_load_by_mail($name);
    }

    if ($user) {
      $administrative_roles = ['administrator', 'moderator'];
      $user_roles = $user->getRoles();
      if (!array_intersect($user_roles, $administrative_roles)) {
        $form_state->setErrorByName('name', t('User @name is not allowed to access backend.', ['@name' => $name]));
      }
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * Revoke user's access if organization has changed (because we store user and organization data
 * in frontend store on login step).
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 */
function anu_user_user_update(EntityInterface $entity) {

  // Collect the affected tokens and expire them.
  if ($entity instanceof AccountInterface) {

    /** @var \Drupal\simple_oauth\ExpiredCollector $collector */
    $collector = \Drupal::service('simple_oauth.expired_collector');

    $origin_organization_ids = array_column($entity->original->field_organization->getValue(), 'target_id');
    $updated_organization_ids = array_column($entity->field_organization->getValue(), 'target_id');

    // When the organization has changed, we should revoke user's access to the site.
    if (!array_diff($origin_organization_ids, $updated_organization_ids)) {
      $collector->deleteMultipleTokens($collector->collectForAccount($entity));
    }
  }

}
