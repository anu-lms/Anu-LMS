<?php

/**
 * @file
 * Module implementation file.
 */

use Drupal\user\Entity\User;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Site\Settings;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Url;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\user\UserInterface;
use Drupal\Core\Access\AccessResult;

/**
 * Implements hook_token_info().
 */
function anu_user_token_info() {
  $info['tokens']['user']['frontend-one-time-login-url'] = [
    'name' => t('One-time login URL to the Frontend'),
    'description' => t('The URL of the one-time login page for the user account.'),
    'restricted' => TRUE,
  ];
  $info['tokens']['site']['frontend-url'] = [
    'name' => t('URL to the Frontend'),
    'description' => t('The URL of the Frontend application.'),
    'restricted' => TRUE,
  ];

  return $info;
}

/**
 * Implements hook_tokens()
 */
function anu_user_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];

  if ($type == 'user' && !empty($data['user'])) {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'frontend-one-time-login-url':

          $replacements[$original] = anu_user_pass_reset_url($data['user'], $options);
          break;
      }
    }
  }
  elseif ($type == 'site') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'frontend-url':

          $replacements[$original] = Settings::get('frontend_domain');
          break;
      }
    }
  }
  return $replacements;
}

/**
 * Generates a unique URL for a user to log in and reset their password.
 *
 * @param \Drupal\user\UserInterface $account
 *   An object containing the user account.
 * @param array $options
 *   (optional) A keyed array of settings. Supported options are:
 *   - langcode: A language code to be used when generating locale-sensitive
 *    URLs. If langcode is NULL the users preferred language is used.
 *
 * @return string
 *   A unique URL that provides a one-time log in for the user, from which
 *   they can change their password.
 */
function anu_user_pass_reset_url(UserInterface $account, array $options = []) {
  $timestamp = \Drupal::time()->getRequestTime();
  $uid = $account->id();
  $hash = user_pass_rehash($account, $timestamp);
  $frontend_domain = Settings::get('frontend_domain');
  $langcode = isset($options['langcode']) ? $options['langcode'] : $account->getPreferredLangcode();
  $url = Url::fromUri($frontend_domain . "user/reset/$uid/$timestamp/$hash",
    [
      'absolute' => TRUE,
      'language' => \Drupal::languageManager()->getLanguage($langcode),
    ]
  );
  return $url->toString();
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function anu_user_form_user_login_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['#validate'][] = '_anu_backend_login_validate';
}

/**
 * Validates user account during backend authentication.
 *
 * Only managers and administrators may access backend.
 */
function _anu_backend_login_validate(&$form, FormStateInterface $form_state) {
  if ($form_state->hasValue('name')) {
    $name = $form_state->getValue('name');

    $user = user_load_by_name($name);

    if (!$user) {
      $user = user_load_by_mail($name);
    }

    if ($user) {
      $administrative_roles = ['administrator', 'moderator'];
      $user_roles = $user->getRoles();
      if (!array_intersect($user_roles, $administrative_roles)) {
        $form_state->setErrorByName('name', t('User @name is not allowed to access backend.', ['@name' => $name]));
      }
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * Revoke user's access if organization has changed (because we store user and
 * organization data in frontend store on login step).
 *
 * Update mentions in comments if username has changed.
 */
function anu_user_user_update(EntityInterface $entity) {

  // Collect the affected tokens and expire them.
  if ($entity instanceof AccountInterface) {

    /** @var \Drupal\simple_oauth\ExpiredCollector $collector */
    $collector = \Drupal::service('simple_oauth.expired_collector');

    $origin_organization_ids = array_column($entity->original->field_organization->getValue(), 'target_id');
    $updated_organization_ids = array_column($entity->field_organization->getValue(), 'target_id');
    $full_diff = array_merge(
      array_diff($origin_organization_ids, $updated_organization_ids),
      array_diff($updated_organization_ids, $origin_organization_ids)
    );

    // When the organization has changed, we should revoke user's access to the site.
    if (count($full_diff) > 0) {
      $collector->deleteMultipleTokens($collector->collectForAccount($entity));
    }

    // Make updates if username has changed.
    if ($entity->original->getAccountName() != $entity->getAccountName()) {
      _update_user_mentions($entity);
    }
  }

}

/**
 * Updates mentions in comments if username has changed.
 *
 * @param \Drupal\Core\Session\AccountInterface $user
 *   User account being updated.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 * @throws \Drupal\Core\Entity\EntityStorageException
 */
function _update_user_mentions(AccountInterface $user) {
  // Check if someone already mentioned this user in comments.
  $comment_ids = \Drupal::entityQuery('paragraph_comment')
    ->condition('field_comment_mentions', $user->id(), 'IN')
    ->execute();
  if ($comment_ids) {
    $controller = \Drupal::entityTypeManager()->getStorage('paragraph_comment');
    $old_name = $user->original->getAccountName();
    $new_name = $user->getAccountName();

    $comments = $controller->loadMultiple($comment_ids);
    /** @var Drupal\Core\Entity\EntityInterface $comment */
    foreach ($comments as $comment) {
      $comment_text = $comment->field_comment_text->getValue();
      $comment_text[0]['value'] = str_replace("@$old_name", "@$new_name", $comment_text[0]['value']);
      $comment->set('field_comment_text', $comment_text);
      $controller->save($comment);
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_access().
 */
function anu_user_user_access(EntityInterface $entity, $operation, AccountInterface $account) {
  // Forbid an access to view user profiles for users who shouldn't have an access to it.
  // User should have an access to other profiles in following cases:
  // - User is admin and has 'administer users' permissions.
  // - User can see accounts of other users from the same organizations.
  // - If user wasn't assigned to any organization, he can see profiles of users without organizations as well.
  if ($operation == 'view') {
    $entity_organization_ids = $account_organization_ids = [];

    $account_entity = User::load($account->id());
    if ($account_entity->hasPermission('administer users')) {
      return AccessResult::neutral();
    }

    // Get organization ids from given user account.
    if (!empty($entity->field_organization->getValue())) {
      $entity_organization_ids = array_column($entity->field_organization->getValue(), 'target_id');
    }

    // Get organization ids from current user.
    if (!empty($account_entity->field_organization->getValue())) {
      $account_organization_ids = array_column($account_entity->field_organization->getValue(), 'target_id');
    }

    // Users without organization can see other users without organizations.
    if (empty($entity_organization_ids) && empty($account_organization_ids)) {
      return AccessResult::neutral();
    }

    // Users with organization can see other users with same organizations.
    $intersect = array_intersect($entity_organization_ids, $account_organization_ids);
    if (!empty($intersect)) {
      return AccessResult::neutral();
    }

    return AccessResult::forbidden();
  }

  return AccessResult::neutral();
}
